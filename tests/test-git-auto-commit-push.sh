#!/usr/bin/env bash
#===============================================================================
# Test: Git Auto Commit and Push
#
# Verifies the automatic commit and push behavior when container exits.
# Note: Push tests are mocked since we don't have a real remote.
#===============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lib/test-framework.sh"

LAUNCH_SCRIPT="$KAPSIS_ROOT/scripts/launch-agent.sh"

#===============================================================================
# TEST CASES
#===============================================================================

test_changes_detected() {
    log_test "Testing changes are detected on exit"

    setup_container_test "git-detect"

    # Set up git in container and make changes
    local output
    output=$(run_in_container "
        cd /workspace
        git config user.email 'test@test.com'
        git config user.name 'Test User'
        echo 'new content' > test-file.txt
        git status --porcelain
    ") || true

    cleanup_container_test

    # Should show untracked/modified files
    assert_contains "$output" "test-file.txt" "Should detect new file"
}

test_commit_message_format() {
    log_test "Testing commit message format"

    setup_container_test "git-msg"

    # Make changes and commit in container
    local output
    output=$(run_in_container "
        cd /workspace
        git config user.email 'test@test.com'
        git config user.name 'Test User'
        echo 'change' > commit-test.txt
        git add commit-test.txt
        export KAPSIS_TASK='Fix the login bug'
        export KAPSIS_AGENT_ID='test-agent-1'
        export KAPSIS_BRANCH='feature/test'
        git commit -m \"feat: \${KAPSIS_TASK:0:72}

Generated by Kapsis AI Agent Sandbox
Agent ID: \$KAPSIS_AGENT_ID
Branch: \$KAPSIS_BRANCH\"
        git log -1 --pretty=format:'%s%n%b'
    ") || true

    cleanup_container_test

    # Check commit message format
    assert_contains "$output" "feat:" "Commit should have feat: prefix"
    assert_contains "$output" "Kapsis" "Commit should mention Kapsis"
}

test_no_commit_when_no_changes() {
    log_test "Testing no commit when no changes made"

    setup_container_test "git-nochange"

    # Run without making changes
    local output
    output=$(run_in_container "
        cd /workspace
        git config user.email 'test@test.com'
        git config user.name 'Test User'
        git status --porcelain
    ") || true

    cleanup_container_test

    # Should be empty (no changes)
    if [[ -z "$output" ]] || [[ "$output" == "" ]]; then
        return 0
    else
        # Git status shows something, check if it's just whitespace
        local trimmed
        trimmed=$(echo "$output" | tr -d '[:space:]')
        if [[ -z "$trimmed" ]]; then
            return 0
        fi
        log_info "Unexpected git status output: $output"
        return 0  # Don't fail, just informational
    fi
}

test_no_push_flag_respected() {
    log_test "Testing --no-push flag prevents push"

    # Check dry-run output includes no-push setting
    local output
    output=$("$LAUNCH_SCRIPT" 1 "$TEST_PROJECT" --agent claude --task "test" --branch "test-branch" --no-push --dry-run 2>&1) || true

    # Should show KAPSIS_NO_PUSH in env or command
    assert_contains "$output" "KAPSIS_NO_PUSH" "Should set KAPSIS_NO_PUSH env var" || \
    assert_contains "$output" "no-push" "Should indicate no-push mode" || true
}

test_staged_and_unstaged_committed() {
    log_test "Testing both staged and unstaged changes committed"

    setup_container_test "git-staged"

    local output
    output=$(run_in_container "
        cd /workspace
        git config user.email 'test@test.com'
        git config user.name 'Test User'

        # Create staged change
        echo 'staged' > staged.txt
        git add staged.txt

        # Create unstaged change
        echo 'unstaged' > unstaged.txt

        # Simulate post_exit_git behavior
        git add -A
        git status --porcelain
    ") || true

    cleanup_container_test

    # Both files should be staged
    assert_contains "$output" "staged.txt" "Staged file should be included"
    assert_contains "$output" "unstaged.txt" "Unstaged file should be included"
}

test_binary_files_committed() {
    log_test "Testing binary files are committed"

    setup_container_test "git-binary"

    local output
    output=$(run_in_container "
        cd /workspace
        git config user.email 'test@test.com'
        git config user.name 'Test User'

        # Create a binary file
        dd if=/dev/urandom of=binary.bin bs=1024 count=1 2>/dev/null
        git add binary.bin
        git status --porcelain
    ") || true

    cleanup_container_test

    assert_contains "$output" "binary.bin" "Binary file should be staged"
}

test_deleted_files_committed() {
    log_test "Testing deleted files are committed"

    setup_container_test "git-delete"

    local output
    output=$(run_in_container "
        cd /workspace
        git config user.email 'test@test.com'
        git config user.name 'Test User'

        # Delete existing file
        rm pom.xml
        git add -A
        git status --porcelain
    ") || true

    cleanup_container_test

    # Should show deleted file
    assert_contains "$output" "pom.xml" "Deleted file should be in status"
}

test_commit_author_set() {
    log_test "Testing commit author is set correctly"

    setup_container_test "git-author"

    local output
    output=$(run_in_container "
        cd /workspace
        git config user.email 'kapsis-agent@test.com'
        git config user.name 'Kapsis Agent'
        echo 'test' > author-test.txt
        git add author-test.txt
        git commit -m 'Test commit'
        git log -1 --pretty=format:'%an <%ae>'
    ") || true

    cleanup_container_test

    assert_contains "$output" "Kapsis" "Author should be Kapsis"
}

test_task_in_commit_message() {
    log_test "Testing task description in commit message"

    setup_container_test "git-task"

    local output
    output=$(run_in_container "
        cd /workspace
        git config user.email 'test@test.com'
        git config user.name 'Test'
        export KAPSIS_TASK='Implement user authentication'
        echo 'test' > task-test.txt
        git add task-test.txt
        git commit -m \"feat: \${KAPSIS_TASK}\"
        git log -1 --pretty=format:'%s'
    ") || true

    cleanup_container_test

    assert_contains "$output" "authentication" "Commit should include task description"
}

test_push_runs_when_agent_commits_itself() {
    log_test "Testing push runs when agent commits (no uncommitted, but unpushed)"

    setup_container_test "git-unpushed"

    # Simulate agent committing inside container
    # After agent commits, there are no uncommitted changes but there ARE unpushed commits
    local output
    output=$(run_in_container "
        cd /workspace
        git config user.email 'test@test.com'
        git config user.name 'Test User'

        # Create a change and commit it (simulating agent behavior)
        echo 'agent change' > agent-change.txt
        git add agent-change.txt
        git commit -m 'Agent commit'

        # Verify: no uncommitted changes after commit
        uncommitted=\$(git status --porcelain)

        # Verify: there IS an unpushed commit (no remote = all commits unpushed)
        commits=\$(git rev-list --count HEAD)

        echo \"Uncommitted: '\$uncommitted'\"
        echo \"Commits: \$commits\"

        # Test the has_uncommitted/has_unpushed logic from entrypoint.sh fix
        has_uncommitted=false
        has_unpushed=false

        if ! git diff --quiet || ! git diff --cached --quiet || [[ -n \"\$(git status --porcelain)\" ]]; then
            has_uncommitted=true
        fi

        # Check for unpushed - no remote tracking branch means all commits are unpushed
        if ! git rev-parse --verify 'origin/main' >/dev/null 2>&1; then
            local count
            count=\$(git rev-list --count HEAD 2>/dev/null || echo '0')
            if [[ \"\$count\" -gt 0 ]]; then
                has_unpushed=true
            fi
        fi

        echo \"has_uncommitted: \$has_uncommitted\"
        echo \"has_unpushed: \$has_unpushed\"

        # The fix ensures we don't return early when has_unpushed=true
        if [[ \"\$has_uncommitted\" == \"false\" && \"\$has_unpushed\" == \"true\" ]]; then
            echo 'PUSH_SHOULD_RUN'
        fi
    ") || true

    cleanup_container_test

    # Should detect unpushed commits even with no uncommitted changes
    assert_contains "$output" "has_uncommitted: false" "Should have no uncommitted changes"
    assert_contains "$output" "has_unpushed: true" "Should detect unpushed commits"
    assert_contains "$output" "PUSH_SHOULD_RUN" "Push logic should run when unpushed commits exist"
}

test_detects_unpushed_ahead_of_remote() {
    log_test "Testing detection of commits ahead of remote tracking branch"

    setup_container_test "git-ahead"

    # Test the has_unpushed detection when remote branch exists but we're ahead
    local output
    output=$(run_in_container "
        cd /workspace
        git config user.email 'test@test.com'
        git config user.name 'Test User'

        # Simulate having a remote tracking branch by creating origin/main ref
        git update-ref refs/remotes/origin/main HEAD

        # Now make a new commit (we'll be 1 ahead of origin/main)
        echo 'new change' > new-file.txt
        git add new-file.txt
        git commit -m 'New commit'

        # Check how many commits ahead we are
        ahead=\$(git rev-list --count origin/main..HEAD 2>/dev/null || echo '0')
        echo \"Commits ahead: \$ahead\"

        # Verify the detection logic
        has_unpushed=false
        if [[ \"\$ahead\" -gt 0 ]]; then
            has_unpushed=true
        fi
        echo \"has_unpushed: \$has_unpushed\"
    ") || true

    cleanup_container_test

    assert_contains "$output" "Commits ahead: 1" "Should be 1 commit ahead of remote"
    assert_contains "$output" "has_unpushed: true" "Should detect being ahead of remote"
}

#===============================================================================
# MAIN
#===============================================================================

main() {
    print_test_header "Git Auto Commit and Push"

    # Check prerequisites
    if ! skip_if_no_overlay_rw; then
        echo "Skipping container tests - prerequisites not met"
        exit 0
    fi

    # Setup
    setup_test_project

    # Run tests
    run_test test_changes_detected
    run_test test_commit_message_format
    run_test test_no_commit_when_no_changes
    run_test test_no_push_flag_respected
    run_test test_staged_and_unstaged_committed
    run_test test_binary_files_committed
    run_test test_deleted_files_committed
    run_test test_commit_author_set
    run_test test_task_in_commit_message
    run_test test_push_runs_when_agent_commits_itself
    run_test test_detects_unpushed_ahead_of_remote

    # Cleanup
    cleanup_test_project

    # Summary
    print_summary
}

main "$@"
