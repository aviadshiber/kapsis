name: CI

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

# Security: Explicitly define minimal permissions
permissions:
  contents: read

# Cancel in-progress runs for the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Check which files changed to determine which tests to run
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      scripts: ${{ steps.filter.outputs.scripts }}
      container: ${{ steps.filter.outputs.container }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
      - uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36  # v3
        id: filter
        with:
          filters: |
            scripts:
              - 'scripts/**'
              - 'tests/**'
              - 'configs/**'
              - 'Containerfile'
              - 'setup.sh'
              - '.github/workflows/ci.yml'
            container:
              - 'Containerfile'
              - 'scripts/entrypoint.sh'
              - 'scripts/build-image.sh'
              - 'scripts/lib/**'
              - '.github/workflows/ci.yml'

  # All test jobs run in parallel after change detection
  lint:
    name: ShellCheck Lint
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.scripts == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - name: Install ShellCheck
        run: sudo apt-get update && sudo apt-get install -y shellcheck

      - name: Find shell scripts
        id: find-scripts
        run: |
          # Find all shell scripts (by extension and shebang)
          scripts=$(find . -type f \( -name "*.sh" -o -name "*.bash" \) ! -path "./.git/*" | sort)
          echo "Found shell scripts:"
          echo "$scripts"
          echo "scripts<<EOF" >> $GITHUB_OUTPUT
          echo "$scripts" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Run ShellCheck
        run: |
          # Run ShellCheck on all shell scripts
          # -S warning: Only fail on warning level and above (not info/style)
          # Other config from .shellcheckrc
          failed=0

          while IFS= read -r script; do
            if [[ -n "$script" ]]; then
              echo "::group::Checking $script"
              if ! shellcheck -S warning "$script"; then
                failed=1
              fi
              echo "::endgroup::"
            fi
          done <<< "${{ steps.find-scripts.outputs.scripts }}"

          if [[ $failed -eq 1 ]]; then
            echo "::error::ShellCheck found issues in one or more scripts"
            exit 1
          fi
          echo "All scripts passed ShellCheck!"

  # Verify supply chain pinning for security
  verify-pinning:
    name: Verify Supply Chain Pinning
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.scripts == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - name: Check base image pinned
        run: |
          echo "Checking Containerfile for pinned base image..."
          if grep -qE "^FROM ubuntu:24\.04$" Containerfile; then
            echo "::error::Base image not pinned to digest in Containerfile"
            echo "Expected: FROM ubuntu@sha256:..."
            echo "Found: FROM ubuntu:24.04 (unpinned tag)"
            exit 1
          fi
          if grep -q "FROM ubuntu@sha256:" Containerfile; then
            echo "✓ Base image is pinned to digest"
          else
            echo "::error::Could not find pinned base image in Containerfile"
            exit 1
          fi

      - name: Check GitHub Actions pinned
        run: |
          echo "Checking workflow files for unpinned actions..."
          unpinned=$(grep -rE "uses:.*@v[0-9]+$" .github/workflows/ 2>/dev/null || true)
          if [[ -n "$unpinned" ]]; then
            echo "::error::Found unpinned GitHub Actions (using floating version tags)"
            echo "$unpinned"
            echo ""
            echo "Actions must be pinned to commit SHAs for security."
            echo "Example: uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6"
            exit 1
          fi
          echo "✓ All GitHub Actions are pinned to commit SHAs"

  config-validation:
    name: Config Validation
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.scripts == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq yamllint
          # Install yq for YAML parsing
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Validate YAML configs
        run: |
          chmod +x ./scripts/lib/config-verifier.sh
          chmod +x ./scripts/hooks/*.sh 2>/dev/null || true
          chmod +x ./scripts/hooks/agent-adapters/*.sh 2>/dev/null || true

          # Run config verifier with pattern matching tests
          ./scripts/lib/config-verifier.sh --all --test

  quick-tests:
    name: Quick Tests
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.scripts == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - name: Install test dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          # Install yq for YAML parsing (pinned version with checksum)
          YQ_VERSION="v4.50.1"
          YQ_SHA256="c7a1278e6bbc4924f41b56db838086c39d13ee25dcb22089e7fbf16ac901f0d4"
          sudo wget -qO /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
          echo "${YQ_SHA256}  /usr/local/bin/yq" | sha256sum -c -
          sudo chmod +x /usr/local/bin/yq

      - name: Configure git for tests
        run: |
          # Configure git identity for test commits
          git config --global user.email "ci@kapsis.test"
          git config --global user.name "Kapsis CI"
          # Disable commit signing in CI environment
          git config --global commit.gpgsign false
          git config --global tag.gpgsign false

      - name: Run quick tests
        run: |
          chmod +x ./tests/run-all-tests.sh
          chmod +x ./tests/*.sh
          chmod +x ./tests/lib/*.sh 2>/dev/null || true
          chmod +x ./scripts/*.sh
          chmod +x ./scripts/lib/*.sh 2>/dev/null || true

          # Run quick tests (no container required)
          ./tests/run-all-tests.sh --quick
        env:
          KAPSIS_TEST_QUIET: "0"

  container-tests:
    name: Container Tests
    runs-on: ubuntu-latest
    needs: changes
    # Only run if container-related files changed (Containerfile, entrypoint, build scripts, libs)
    if: needs.changes.outputs.container == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - name: Configure git for tests
        run: |
          git config --global user.email "ci@kapsis.test"
          git config --global user.name "Kapsis CI"
          git config --global commit.gpgsign false
          git config --global tag.gpgsign false

      - name: Install Podman
        run: |
          sudo apt-get update
          sudo apt-get install -y podman fuse-overlayfs slirp4netns jq
          # Install yq for YAML parsing (pinned version with checksum)
          YQ_VERSION="v4.50.1"
          YQ_SHA256="c7a1278e6bbc4924f41b56db838086c39d13ee25dcb22089e7fbf16ac901f0d4"
          sudo wget -qO /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
          echo "${YQ_SHA256}  /usr/local/bin/yq" | sha256sum -c -
          sudo chmod +x /usr/local/bin/yq

      - name: Configure Podman for rootless
        run: |
          # Set up rootless Podman
          mkdir -p ~/.config/containers
          echo '[storage]' > ~/.config/containers/storage.conf
          echo 'driver = "overlay"' >> ~/.config/containers/storage.conf

          # Verify Podman installation
          podman --version
          podman info --debug 2>&1 | head -20 || true

      - name: Generate cache key
        id: cache-key
        run: |
          # Cache key based on Containerfile and base image references
          echo "key=kapsis-image-${{ hashFiles('Containerfile', 'scripts/build-image.sh') }}" >> $GITHUB_OUTPUT

      - name: Restore cached container image
        id: cache-restore
        uses: actions/cache/restore@9255dc7a253b0ccc959486e2bca901246202afeb  # v5
        with:
          path: /tmp/kapsis-image.tar
          key: ${{ steps.cache-key.outputs.key }}

      - name: Load cached image or build new
        run: |
          chmod +x ./scripts/build-image.sh
          if [[ -f /tmp/kapsis-image.tar ]]; then
            echo "Loading cached container image..."
            podman load -i /tmp/kapsis-image.tar
            echo "Cached image loaded successfully"
          else
            echo "No cache found, building fresh image..."
            ./scripts/build-image.sh --name kapsis-test --tag ci
          fi
        timeout-minutes: 30

      - name: Save image to cache
        if: steps.cache-restore.outputs.cache-hit != 'true'
        run: |
          echo "Saving image to cache..."
          podman save kapsis-test:ci -o /tmp/kapsis-image.tar

      - name: Upload image cache
        if: steps.cache-restore.outputs.cache-hit != 'true'
        uses: actions/cache/save@9255dc7a253b0ccc959486e2bca901246202afeb  # v5
        with:
          path: /tmp/kapsis-image.tar
          key: ${{ steps.cache-key.outputs.key }}

      - name: Run container tests
        run: |
          chmod +x ./tests/run-all-tests.sh
          chmod +x ./tests/*.sh
          chmod +x ./tests/lib/*.sh 2>/dev/null || true
          chmod +x ./scripts/*.sh
          chmod +x ./scripts/lib/*.sh 2>/dev/null || true

          # Run all tests (includes container tests)
          ./tests/run-all-tests.sh
        timeout-minutes: 45
        env:
          KAPSIS_TEST_QUIET: "0"
          KAPSIS_IMAGE: "kapsis-test:ci"

  # Summary job that all required checks depend on
  ci-success:
    name: CI Success
    runs-on: ubuntu-latest
    needs: [changes, lint, verify-pinning, config-validation, quick-tests, container-tests]
    if: always()
    steps:
      - name: Check all jobs passed
        run: |
          # If no script changes, all tests are skipped - that's OK
          if [[ "${{ needs.changes.outputs.scripts }}" != "true" ]]; then
            echo "No script changes detected - CI tests skipped"
            echo "Files changed: docs, assets, or other non-code files"
            exit 0
          fi

          # Script changes detected - lint, verify-pinning, config-validation, and quick-tests must pass
          if [[ "${{ needs.lint.result }}" != "success" ]]; then
            echo "Lint job failed"
            exit 1
          fi
          if [[ "${{ needs.verify-pinning.result }}" != "success" ]]; then
            echo "Supply chain pinning verification job failed"
            exit 1
          fi
          if [[ "${{ needs.config-validation.result }}" != "success" ]]; then
            echo "Config validation job failed"
            exit 1
          fi
          if [[ "${{ needs.quick-tests.result }}" != "success" ]]; then
            echo "Quick tests job failed"
            exit 1
          fi

          # Container tests only required if container-related files changed
          if [[ "${{ needs.changes.outputs.container }}" == "true" ]]; then
            if [[ "${{ needs.container-tests.result }}" != "success" ]]; then
              echo "Container tests job failed"
              exit 1
            fi
            echo "All CI checks passed (including container tests)!"
          else
            echo "All CI checks passed (container tests skipped - no container changes)!"
          fi
