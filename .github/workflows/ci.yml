name: CI

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

# Security: Explicitly define minimal permissions
permissions:
  contents: read

# Cancel in-progress runs for the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Check which files changed to determine which tests to run
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      scripts: ${{ steps.filter.outputs.scripts }}
      container: ${{ steps.filter.outputs.container }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
      - uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36  # v3
        id: filter
        with:
          filters: |
            scripts:
              - 'scripts/**'
              - 'tests/**'
              - 'configs/**'
              - 'Containerfile'
              - 'setup.sh'
              - '.github/workflows/ci.yml'
            container:
              - 'Containerfile'
              - 'scripts/entrypoint.sh'
              - 'scripts/build-image.sh'
              - 'scripts/lib/**'
              - '.github/workflows/ci.yml'

  # All test jobs run in parallel after change detection
  lint:
    name: ShellCheck Lint
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.scripts == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - name: Install ShellCheck
        run: sudo apt-get update && sudo apt-get install -y shellcheck

      - name: Find shell scripts
        id: find-scripts
        run: |
          # Find all shell scripts (by extension and shebang)
          scripts=$(find . -type f \( -name "*.sh" -o -name "*.bash" \) ! -path "./.git/*" | sort)
          echo "Found shell scripts:"
          echo "$scripts"
          echo "scripts<<EOF" >> $GITHUB_OUTPUT
          echo "$scripts" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Run ShellCheck
        run: |
          # Run ShellCheck on all shell scripts
          # -S warning: Only fail on warning level and above (not info/style)
          # Other config from .shellcheckrc
          failed=0

          while IFS= read -r script; do
            if [[ -n "$script" ]]; then
              echo "::group::Checking $script"
              if ! shellcheck -S warning "$script"; then
                failed=1
              fi
              echo "::endgroup::"
            fi
          done <<< "${{ steps.find-scripts.outputs.scripts }}"

          if [[ $failed -eq 1 ]]; then
            echo "::error::ShellCheck found issues in one or more scripts"
            exit 1
          fi
          echo "All scripts passed ShellCheck!"

  # Verify supply chain pinning for security
  verify-pinning:
    name: Verify Supply Chain Pinning
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.scripts == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - name: Verify base image digest pinning
        run: |
          echo "Verifying base image supply chain pinning..."

          # 1. Check Containerfile uses digest reference (not floating tag)
          if grep -qE "^FROM ubuntu:24\.04$" Containerfile; then
            echo "::error::Base image not pinned to digest in Containerfile"
            echo "Found: FROM ubuntu:24.04 (unpinned floating tag)"
            exit 1
          fi

          if ! grep -q 'FROM ubuntu@\${BASE_IMAGE_DIGEST}' Containerfile; then
            echo "::error::Containerfile must use FROM ubuntu@\${BASE_IMAGE_DIGEST}"
            exit 1
          fi
          echo "✓ Containerfile uses digest reference"

          # 2. Extract and validate digests from build-image.sh
          echo ""
          echo "Extracting pinned digests from build-image.sh..."

          # Extract digests (format: ["linux/amd64"]="sha256:...")
          digests=$(grep -oE 'sha256:[a-f0-9]{64}' scripts/build-image.sh || true)

          if [[ -z "$digests" ]]; then
            echo "::error::No valid SHA256 digests found in build-image.sh"
            exit 1
          fi

          # 3. Validate format and verify digests exist in Docker registry
          echo ""
          echo "Verifying digests..."

          for digest in $digests; do
            echo -n "  $digest "

            # Verify digest format (sha256: + 64 hex chars)
            if ! echo "$digest" | grep -qE '^sha256:[a-f0-9]{64}$'; then
              echo ""
              echo "::error::Invalid digest format: $digest"
              exit 1
            fi

            # Query Docker Registry V2 API to verify digest exists
            # Get auth token first (required even for public images)
            token=$(curl -s "https://auth.docker.io/token?service=registry.docker.io&scope=repository:library/ubuntu:pull" \
              --max-time 10 | jq -r '.token' 2>/dev/null || echo "")

            if [[ -z "$token" || "$token" == "null" ]]; then
              echo "⚠ skipped (auth unavailable)"
              continue
            fi

            # Check if digest exists by requesting manifest
            http_code=$(curl -s -o /dev/null -w "%{http_code}" \
              -H "Authorization: Bearer $token" \
              -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \
              "https://registry-1.docker.io/v2/library/ubuntu/manifests/$digest" \
              --max-time 10 || echo "000")

            case "$http_code" in
              200) echo "✓ exists in registry" ;;
              404)
                echo ""
                echo "::error::Digest not found in Docker Hub: $digest"
                echo "This digest does not exist or may have been tampered with."
                exit 1
                ;;
              000) echo "⚠ skipped (network timeout)" ;;
              *)   echo "⚠ skipped (http $http_code)" ;;
            esac
          done

          echo ""
          echo "✓ All base image digests verified"

      - name: Check GitHub Actions pinned
        run: |
          echo "Checking workflow files for unpinned actions..."
          unpinned=$(grep -rE "uses:.*@v[0-9]+$" .github/workflows/ 2>/dev/null || true)
          if [[ -n "$unpinned" ]]; then
            echo "::error::Found unpinned GitHub Actions (using floating version tags)"
            echo "$unpinned"
            echo ""
            echo "Actions must be pinned to commit SHAs for security."
            echo "Example: uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6"
            exit 1
          fi
          echo "✓ All GitHub Actions are pinned to commit SHAs"

  config-validation:
    name: Config Validation
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.scripts == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq yamllint
          # Install yq for YAML parsing
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Validate YAML configs
        run: |
          chmod +x ./scripts/lib/config-verifier.sh
          chmod +x ./scripts/hooks/*.sh 2>/dev/null || true
          chmod +x ./scripts/hooks/agent-adapters/*.sh 2>/dev/null || true

          # Run config verifier with pattern matching tests
          ./scripts/lib/config-verifier.sh --all --test

  quick-tests:
    name: Quick Tests
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.scripts == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - name: Install test dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          # Install yq for YAML parsing (pinned version with checksum)
          YQ_VERSION="v4.50.1"
          YQ_SHA256="c7a1278e6bbc4924f41b56db838086c39d13ee25dcb22089e7fbf16ac901f0d4"
          sudo wget -qO /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
          echo "${YQ_SHA256}  /usr/local/bin/yq" | sha256sum -c -
          sudo chmod +x /usr/local/bin/yq

      - name: Configure git for tests
        run: |
          # Configure git identity for test commits
          git config --global user.email "ci@kapsis.test"
          git config --global user.name "Kapsis CI"
          # Disable commit signing in CI environment
          git config --global commit.gpgsign false
          git config --global tag.gpgsign false

      - name: Run quick tests
        run: |
          chmod +x ./tests/run-all-tests.sh
          chmod +x ./tests/*.sh
          chmod +x ./tests/lib/*.sh 2>/dev/null || true
          chmod +x ./scripts/*.sh
          chmod +x ./scripts/lib/*.sh 2>/dev/null || true

          # Run quick tests (no container required)
          ./tests/run-all-tests.sh --quick
        env:
          KAPSIS_TEST_QUIET: "0"

  container-tests:
    name: Container Tests
    runs-on: ubuntu-latest
    needs: changes
    # Only run if container-related files changed (Containerfile, entrypoint, build scripts, libs)
    if: needs.changes.outputs.container == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - name: Configure git for tests
        run: |
          git config --global user.email "ci@kapsis.test"
          git config --global user.name "Kapsis CI"
          git config --global commit.gpgsign false
          git config --global tag.gpgsign false

      - name: Install Podman
        run: |
          sudo apt-get update
          sudo apt-get install -y podman fuse-overlayfs slirp4netns jq
          # Install yq for YAML parsing (pinned version with checksum)
          YQ_VERSION="v4.50.1"
          YQ_SHA256="c7a1278e6bbc4924f41b56db838086c39d13ee25dcb22089e7fbf16ac901f0d4"
          sudo wget -qO /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
          echo "${YQ_SHA256}  /usr/local/bin/yq" | sha256sum -c -
          sudo chmod +x /usr/local/bin/yq

      - name: Configure Podman for rootless
        run: |
          # Set up rootless Podman
          mkdir -p ~/.config/containers
          echo '[storage]' > ~/.config/containers/storage.conf
          echo 'driver = "overlay"' >> ~/.config/containers/storage.conf

          # Verify Podman installation
          podman --version
          podman info --debug 2>&1 | head -20 || true

      - name: Generate cache key
        id: cache-key
        run: |
          # Cache key based on Containerfile, build script, and runner architecture
          echo "key=kapsis-image-${{ runner.arch }}-${{ hashFiles('Containerfile', 'scripts/build-image.sh') }}" >> $GITHUB_OUTPUT

      - name: Restore cached container image
        id: cache-restore
        uses: actions/cache/restore@9255dc7a253b0ccc959486e2bca901246202afeb  # v5
        with:
          path: /tmp/kapsis-image.tar
          key: ${{ steps.cache-key.outputs.key }}

      - name: Load cached image or build new
        run: |
          chmod +x ./scripts/build-image.sh
          if [[ -f /tmp/kapsis-image.tar ]]; then
            echo "Loading cached container image..."
            podman load -i /tmp/kapsis-image.tar
            echo "Cached image loaded successfully"
          else
            echo "No cache found, building fresh image..."
            ./scripts/build-image.sh --name kapsis-test --tag ci
          fi
        timeout-minutes: 30

      - name: Save image to cache
        if: steps.cache-restore.outputs.cache-hit != 'true'
        run: |
          echo "Saving image to cache..."
          podman save kapsis-test:ci -o /tmp/kapsis-image.tar

      - name: Upload image cache
        if: steps.cache-restore.outputs.cache-hit != 'true'
        uses: actions/cache/save@9255dc7a253b0ccc959486e2bca901246202afeb  # v5
        with:
          path: /tmp/kapsis-image.tar
          key: ${{ steps.cache-key.outputs.key }}

      - name: Run container tests
        run: |
          chmod +x ./tests/run-all-tests.sh
          chmod +x ./tests/*.sh
          chmod +x ./tests/lib/*.sh 2>/dev/null || true
          chmod +x ./scripts/*.sh
          chmod +x ./scripts/lib/*.sh 2>/dev/null || true

          # Run all tests (includes container tests)
          ./tests/run-all-tests.sh
        timeout-minutes: 45
        env:
          KAPSIS_TEST_QUIET: "0"
          KAPSIS_IMAGE: "kapsis-test:ci"

  # Summary job that all required checks depend on
  ci-success:
    name: CI Success
    runs-on: ubuntu-latest
    needs: [changes, lint, verify-pinning, config-validation, quick-tests, container-tests]
    if: always()
    steps:
      - name: Check all jobs passed
        run: |
          # If no script changes, all tests are skipped - that's OK
          if [[ "${{ needs.changes.outputs.scripts }}" != "true" ]]; then
            echo "No script changes detected - CI tests skipped"
            echo "Files changed: docs, assets, or other non-code files"
            exit 0
          fi

          # Script changes detected - lint, verify-pinning, config-validation, and quick-tests must pass
          if [[ "${{ needs.lint.result }}" != "success" ]]; then
            echo "Lint job failed"
            exit 1
          fi
          if [[ "${{ needs.verify-pinning.result }}" != "success" ]]; then
            echo "Supply chain pinning verification job failed"
            exit 1
          fi
          if [[ "${{ needs.config-validation.result }}" != "success" ]]; then
            echo "Config validation job failed"
            exit 1
          fi
          if [[ "${{ needs.quick-tests.result }}" != "success" ]]; then
            echo "Quick tests job failed"
            exit 1
          fi

          # Container tests only required if container-related files changed
          if [[ "${{ needs.changes.outputs.container }}" == "true" ]]; then
            if [[ "${{ needs.container-tests.result }}" != "success" ]]; then
              echo "Container tests job failed"
              exit 1
            fi
            echo "All CI checks passed (including container tests)!"
          else
            echo "All CI checks passed (container tests skipped - no container changes)!"
          fi
