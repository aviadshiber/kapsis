# Kapsis Security Vulnerability Scan Report

**Date:** 2026-02-21
**Previous Scan:** 2025-12-26
**Scope:** Comprehensive security audit of the Kapsis codebase (v2.7.1)
**Status:** Complete

---

## Executive Summary

This report presents findings from a comprehensive security vulnerability scan of the Kapsis codebase. It supersedes the previous scan from 2025-12-26. The analysis covered container isolation, shell script security, secrets handling, file permissions, network security, git workflow security, CI/CD pipeline security, and supply chain integrity.

**Overall Security Posture:** STRONG — significant improvements since last scan

| Severity | Previous | Current | Trend |
|----------|----------|---------|-------|
| CRITICAL | 5 | 1 | Improved |
| HIGH | 8 | 4 | Improved |
| MEDIUM | 12 | 11 | Improved |
| LOW | 6 | 5 | Improved |

### Remediation Progress Since 2025-12-26

| Issue | Previous Status | Current Status |
|-------|----------------|----------------|
| 1.1 yq unverified download | CRITICAL | FIXED — SHA256 verified on amd64, pinned to v4.44.3 |
| 1.1 SDKMAN curl\|bash | CRITICAL | IMPROVED — Downloaded to file first (no hash) |
| 1.1 NVM curl\|bash | CRITICAL | IMPROVED — Downloaded to file first (no hash) |
| 1.2 eval injection in keychain | CRITICAL | FIXED — Parameter expansion replaces eval |
| 1.3 Credential file race condition | CRITICAL | FIXED — umask 0077 before file creation |
| 1.4 GitHub Actions unpinned | CRITICAL | FIXED — All actions pinned to SHA hashes |
| 1.5 Unquoted $VERSION | CRITICAL | FIXED — Version format validated via regex |
| 2.2 Worktree a+rwX permissions | HIGH | FIXED — Uses u+rwX,g+rX |
| 2.4 Log files without permissions | HIGH | FIXED — chmod 600 after creation |
| 2.5 eval in log_cmd | HIGH | FIXED — Uses "$@" instead of eval |
| 2.8 Missing CI permissions | HIGH | FIXED — permissions: contents: read |
| 3.1 No default network isolation | MEDIUM | FIXED — Default "filtered" mode with DNS allowlist |
| 3.2 No seccomp profiles | MEDIUM | FIXED — Seccomp profiles implemented in security.sh |
| 3.4 Base image not pinned | MEDIUM | FIXED — Pinned to SHA256 digest |

---

## Table of Contents

1. [Critical Vulnerabilities](#1-critical-vulnerabilities)
2. [High Severity Issues](#2-high-severity-issues)
3. [Medium Severity Issues](#3-medium-severity-issues)
4. [Low Severity Issues](#4-low-severity-issues)
5. [Positive Security Findings](#5-positive-security-findings)
6. [Remaining Gaps](#6-remaining-gaps)
7. [Remediation Roadmap](#7-remediation-roadmap)

---

## 1. Critical Vulnerabilities

### 1.1 Supply Chain: SDKMAN/NVM/Rust/Go Downloaded Without Hash Verification

**Files:**
- `Containerfile:209-211` (SDKMAN)
- `Containerfile:249-251` (NVM)
- `Containerfile:273-274` (Rust)
- `Containerfile:292` (Go)

**Issue:** While SDKMAN and NVM scripts are now downloaded to files before execution (improving over direct curl|bash), none of these downloads include SHA256 hash verification. Rust still uses the curl|sh anti-pattern. Go is downloaded via curl|tar with no integrity check.

```dockerfile
# SDKMAN — downloaded to file, but no hash check
curl -sL "https://get.sdkman.io?rcupdate=false" -o /tmp/sdkman-install.sh && \
bash /tmp/sdkman-install.sh

# NVM — downloaded to file, but no hash check
curl -sL "https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh" -o /tmp/nvm-install.sh && \
bash /tmp/nvm-install.sh

# Rust — still uses curl|sh pattern
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y

# Go — no integrity verification
curl -sL "https://go.dev/dl/go${GO_VERSION}.linux-${ARCH}.tar.gz" | tar -C /opt -xz
```

**Risk:** Supply chain compromise if upstream servers are compromised. An attacker who controls the download URL can inject arbitrary code that runs during image build with full privileges.

**Note:** yq now has SHA256 verification on amd64 (Containerfile:63,187-189), but the check is non-fatal on hash mismatch (prints warning instead of failing) and arm64 builds skip verification entirely.

**Remediation:**
1. Add SHA256 checksums for SDKMAN and NVM install scripts
2. Download Rust installer to file, verify hash, then execute
3. Verify Go tarball checksum before extraction
4. Make yq hash verification fatal (remove the warning-only fallback)
5. Add arm64 SHA256 hash for yq

---

## 2. High Severity Issues

### 2.1 World-Writable Directories in Test Framework

**File:** `tests/lib/test-framework.sh`

```bash
chmod 777 "$CONTAINER_TEST_UPPER" "$CONTAINER_TEST_SANDBOX/work"
```

**Risk:** World-writable directories could allow privilege escalation in test environments. While this is test-only code, it establishes unsafe patterns.

**Remediation:** Use `chmod 755` or `770` for overlay directories.

---

### 2.2 CUSTOM_PACKAGES Unquoted in Containerfile

**File:** `Containerfile:172`

```dockerfile
RUN if [ -n "$CUSTOM_PACKAGES" ]; then \
        apt-get update && apt-get install -y --no-install-recommends $CUSTOM_PACKAGES && \
```

**Issue:** `$CUSTOM_PACKAGES` is intentionally unquoted for word splitting (to install multiple packages), but this means a malicious build argument could inject shell metacharacters. Since this is a build-time argument controlled by the image builder, risk is limited to build-time compromise.

**Risk:** If an attacker controls the `--build-arg CUSTOM_PACKAGES=...` value, they could inject commands. In practice, this is operator-controlled.

**Remediation:** Document that `CUSTOM_PACKAGES` must be sanitized. Consider validating input against a `^[a-zA-Z0-9. -]+$` pattern in `build-image.sh`.

---

### 2.3 AGENT_SCRIPT Arbitrary Execution in Containerfile

**File:** `Containerfile:440-442`

```dockerfile
RUN if [ -n "$AGENT_SCRIPT" ]; then \
        echo "Running agent install script: $AGENT_SCRIPT" && \
        bash -c "$AGENT_SCRIPT" && \
```

**Issue:** The `AGENT_SCRIPT` build argument is executed directly via `bash -c`. This is by design for installing agents (e.g., `curl -fsSL https://claude.ai/install.sh | bash`), but represents a code execution vector at build time.

**Risk:** Anyone who controls build arguments can execute arbitrary code. This is expected behavior but should be clearly documented as a trust boundary.

**Remediation:** Document that `AGENT_SCRIPT` is a trusted input. Consider adding an allowlist of approved agent install commands.

---

### 2.4 AGENT_COMMAND From Config Passed to bash -c Without Validation

**File:** `scripts/launch-agent.sh:731,1811-1813`

```bash
AGENT_COMMAND=$(yq -r '.agent.command // "bash"' "$CONFIG_FILE")
...
CONTAINER_CMD+=("bash" "-c" "$AGENT_COMMAND")
```

**Issue:** The `agent.command` value from YAML config files is read via yq and passed directly to `bash -c` inside the container. While config files are validated for trusted locations (lines 553-627), there is no content validation on the command string itself.

**Mitigations already in place:**
- Config files must come from trusted locations (project root, `~/.config/kapsis/`, or built-in agents)
- Config file permissions are checked (warns if world-readable)
- The command executes inside an isolated container (not on host)

**Risk:** If an attacker can modify a trusted config file (e.g., `.kapsis/config.yaml` in a cloned repo), they can execute arbitrary commands inside the container. Container isolation limits blast radius.

**Remediation:** Add content validation or a command allowlist in `config-verifier.sh`. At minimum, validate that the command starts with a known agent binary name.

---

## 3. Medium Severity Issues

### 3.1 LSM (AppArmor/SELinux) Falls Back to Disabled

**File:** `scripts/lib/security.sh:324,347,361,367`

**Issue:** When AppArmor/SELinux profiles are not installed, the system falls back to `label=disable`, removing mandatory access control. The `paranoid` profile requires LSM, but `standard` and `strict` profiles silently degrade.

**Remediation:** Log a prominent warning when LSM is disabled. Consider making LSM required for `strict` profile as well.

---

### 3.2 Secrets Env File TOCTOU Window

**File:** `scripts/launch-agent.sh:1508-1510`

```bash
if ! SECRETS_ENV_FILE=$(mktemp "${TMPDIR:-/tmp}/kapsis-secrets-XXXXXX" 2>/dev/null); then
    ...
fi
chmod 600 "$SECRETS_ENV_FILE"
```

**Issue:** The temp file is created by `mktemp` (which uses the process umask) and then `chmod 600` is applied afterward. There is a brief window between file creation and permission restriction. However, the temp file name is unpredictable (mktemp uses random suffix), which mitigates practical exploitation.

**Remediation:** Set `umask 0077` before the mktemp call, matching the pattern used in `entrypoint.sh`.

---

### 3.3 eval of dbus-launch Output

**File:** `scripts/entrypoint.sh:191`

```bash
dbus_output=$(dbus-launch --sh-syntax 2>/dev/null) || { ... }
eval "$dbus_output"
```

**Issue:** The output of `dbus-launch --sh-syntax` is eval'd. While `dbus-launch` is a system binary with deterministic output (DBUS_SESSION_BUS_ADDRESS and DBUS_SESSION_BUS_PID assignments), a compromised dbus-launch binary could inject arbitrary commands.

**Mitigations already in place:** This runs inside an isolated container. The container image is built from trusted sources.

**Remediation:** Parse the output using parameter expansion instead of eval, or validate the output format before eval.

---

### 3.4 eval in Logging Timer Functions

**File:** `scripts/lib/logging.sh:498`

```bash
eval "_KAPSIS_TIMER_${timer_name}=$(date +%s)"
```

**Issue:** Timer names are used in eval to create dynamic variable names.

**Mitigations already in place:** Timer names are validated against `^[a-zA-Z0-9_]+$` regex (line 494), which prevents injection. The validation is correct and sufficient.

**Remediation:** Consider using an associative array (Bash 4+) instead of eval for dynamic variable names: `declare -A _KAPSIS_TIMERS; _KAPSIS_TIMERS[$timer_name]=$(date +%s)`.

---

### 3.5 Seccomp Allows unshare/setns Syscalls

**File:** `security/seccomp/kapsis-agent-base.json`

**Issue:** The seccomp profile allows `unshare` and `setns` syscalls, which enable namespace operations. While needed by some build tools, these syscalls could enable namespace escape attacks if combined with kernel vulnerabilities.

**Mitigations already in place:** Container runs as non-root with `--userns=keep-id` and `no-new-privileges`. The `defaultAction: SCMP_ACT_ERRNO` blocks most dangerous syscalls (ptrace, mount, bpf, keyctl).

**Remediation:** Consider restricting `setns`/`unshare` with argument-level filtering, or blocking them entirely in `strict`/`paranoid` profiles.

---

### 3.6 DNS Wildcard Domains Cannot Be IP-Pinned

**Files:**
- `scripts/lib/dns-filter.sh:266-270`
- `scripts/lib/dns-pin.sh:88-92`

**Issue:** Wildcard domains (e.g., `*.example.com`) in the network allowlist cannot be IP-pinned. The code logs a security warning but allows the wildcard through with dynamic DNS resolution only.

```bash
if [[ "$domain" == "*."* ]]; then
    log_warn "SECURITY: Wildcard '$domain' cannot be IP-pinned - vulnerable to DNS manipulation"
fi
```

**Risk:** If DNS responses for wildcard domains are poisoned (via cache poisoning or MITM), traffic could be redirected.

**Remediation:** Block wildcards in `strict`/`paranoid` security profiles. Document the risk for `standard` profile users.

---

### 3.7 Symlink Following in Filesystem Snapshots

**File:** `scripts/launch-agent.sh:1094-1101`

**Issue:** Filesystem snapshots use `cp -a` which preserves symlinks but follows them when copying. If a snapshotted directory (e.g., `~/.ssh`) contains symlinks to sensitive files outside the intended scope, those files would be included in the snapshot and made available to the container.

**Remediation:** Use `cp -P` to preserve symlinks without following them, or validate targets before snapshotting.

---

### 3.8 Sed Pattern Injection

**File:** `scripts/launch-agent.sh`

```bash
find "$UPPER_DIR" -type f 2>/dev/null | sed "s|^${UPPER_DIR}/|  |"
```

**Issue:** If `$UPPER_DIR` contains sed metacharacters, pattern matching could fail or behave unexpectedly. In practice, `UPPER_DIR` is a system-generated path under `~/.kapsis/`, so metacharacters are unlikely.

**Remediation:** Escape the variable or use an alternative approach (e.g., `cut` or parameter expansion in a while loop).

---

### 3.9 Branch Protection Not Automatic

**File:** `scripts/setup-github-protection.sh`

**Issue:** GitHub branch protection is available via setup script but not enforced. Repositories can be used without branch protection.

**Remediation:** Add a preflight warning when branch protection is not configured.

---

### 3.10 No Commit Signing

**Issue:** Agent commits are not GPG/SSH signed, making it impossible to verify that commits were actually made by the agent sandbox.

**Remediation:** Add optional commit signing feature.

---

### 3.11 RELEASE_TOKEN Scope Unknown

**File:** `.github/workflows/auto-release.yml`

**Issue:** Custom PAT token (`RELEASE_TOKEN`) used without documented scope restrictions.

**Remediation:** Document required token scopes (typically `contents: write`, `packages: write`).

---

## 4. Low Severity Issues

### 4.1 yq Checksum Non-Fatal and Missing for arm64

**File:** `Containerfile:187-192`

```dockerfile
if [ -n "$YQ_SHA256" ] && [ "$ARCH" = "amd64" ]; then \
    echo "${YQ_SHA256}  /tmp/yq" | sha256sum -c - || \
    { echo "WARNING: yq checksum mismatch - script may have been updated."; }; \
fi
```

**Issue:** Hash mismatch prints a warning but does not fail the build. arm64 builds skip verification entirely.

**Remediation:** Make the hash check fatal. Add an arm64 hash.

---

### 4.2 Subshell Variable Loss in Piped Loops

**Files:**
- `scripts/merge-changes.sh:102`
- `scripts/worktree-manager.sh:665`
- `scripts/lib/agent-types.sh:320`

**Issue:** Variables assigned inside `while read` loops fed by pipes run in subshells, so assignments are lost after the loop. This is a correctness issue, not directly a security vulnerability, but could lead to logic errors in security-relevant code paths.

**Remediation:** Use process substitution: `while read -r line; do ... done < <(command)`.

---

### 4.3 Log Directory Permissions Not Validated

**File:** `scripts/lib/logging.sh`

**Issue:** Log directory created via `mkdir -p` without explicit permissions. Inherits process umask.

**Remediation:** Add `chmod 0700 "$KAPSIS_LOG_DIR"` after directory creation.

---

### 4.4 eval in Test Framework

**File:** `tests/lib/test-framework.sh:460,473,488,503,773`

**Issue:** Test assertion functions use eval to execute commands. This is test-only code with controlled inputs, but establishes a pattern that could be unsafe if test inputs become dynamic.

**Remediation:** Ensure test inputs remain controlled. Consider converting to `"$@"` pattern where possible.

---

### 4.5 Status File Path Validation Uses String Prefix

**File:** `scripts/lib/status.sh:454`

```bash
local allowed_prefix="/workspace/.kapsis/"
if [[ "$canonical_path" != "${allowed_prefix}"* ]]; then
    return 0
fi
```

**Issue:** String prefix matching could theoretically be bypassed (e.g., `/workspace/.kapsis-evil/` would not match due to the trailing `/`, but edge cases exist). The `realpath -m` canonicalization (line 451) mitigates most concerns.

**Remediation:** Consider stricter path component validation.

---

## 5. Positive Security Findings

The following security measures are well-implemented:

| Feature | Status | Evidence |
|---------|--------|----------|
| Rootless Podman | EXCELLENT | `--userns=keep-id` always enabled |
| Non-root container user | EXCELLENT | `USER developer` in Containerfile |
| Base image pinned to digest | EXCELLENT | `ubuntu@sha256:...` in Containerfile:18 |
| GitHub Actions pinned to SHA | EXCELLENT | All `uses:` entries pinned to commit hashes |
| CI enforces action pinning | EXCELLENT | ci.yml:182 checks for unpinned actions |
| Empty git hooks directory | EXCELLENT | worktree-manager.sh sanitization |
| FSCK object validation | EXCELLENT | `fsckObjects = true` in git config |
| Read-only git objects mount | EXCELLENT | `:ro` mount flags |
| Credential file umask protection | EXCELLENT | `umask 0077` before file creation |
| Secrets passed via env-file | EXCELLENT | `--env-file` prevents ps exposure |
| Secrets masking in logs | EXCELLENT | Regex-based sanitization of all log levels |
| Environment variable unsetting | EXCELLENT | Credentials unset after file injection |
| Parameter expansion over eval | EXCELLENT | Keychain account uses safe `${//}` substitution |
| log_cmd uses "$@" | EXCELLENT | No eval in command execution |
| Log files have permissions | EXCELLENT | `chmod 600` after creation |
| Input validation on agent IDs | EXCELLENT | `^[a-zA-Z0-9_-]+$` regex validation |
| Git repo path validation | EXCELLENT | `^[a-zA-Z0-9._-]+/[a-zA-Z0-9._-]+$` regex |
| Timer name validation | GOOD | `^[a-zA-Z0-9_]+$` before eval |
| SSH key fingerprint verification | GOOD | Validates against official APIs |
| Per-agent Maven repositories | GOOD | SNAPSHOT blocking |
| Network isolation modes | GOOD | Default "filtered" with DNS allowlist |
| Seccomp profile support | GOOD | Agent-specific profiles with fallback |
| Security profile tiers | GOOD | minimal/standard/strict/paranoid |
| Capability dropping | GOOD | `--cap-drop=ALL` with minimal add-back |
| Resource limits | GOOD | Memory, CPU, PID limits enforced |
| CODEOWNERS configured | GOOD | All critical paths covered |
| Dependabot enabled | GOOD | Weekly updates for actions/images |
| Secret scanning (TruffleHog) | GOOD | Runs on push and PR |
| ShellCheck in CI | GOOD | SARIF upload to security tab |
| Trivy container scanning | GOOD | CRITICAL/HIGH vulnerabilities reported |
| Dependency review | GOOD | Runs on PRs via actions/dependency-review-action |
| No hardcoded secrets | GOOD | Only test data, no real keys |
| HTTPS for all downloads | GOOD | No HTTP fallbacks |
| CI workflow permissions | GOOD | Explicit minimal permissions blocks |
| Atomic file operations | GOOD | atomic-copy.sh prevents corruption |
| Filesystem scope enforcement | GOOD | validate-scope.sh blocks out-of-bounds writes |
| File sanitization | GOOD | Trojan Source / homoglyph detection |
| Worktree permissions | GOOD | `u+rwX,g+rX` instead of world-writable |

---

## 6. Remaining Gaps

### 6.1 Open Issues

| Feature | Severity | Gap |
|---------|----------|-----|
| Build-time download integrity | CRITICAL | SDKMAN/NVM/Rust/Go have no hash verification |
| LSM profile availability | MEDIUM | Falls back to disabled without profiles installed |
| Seccomp unshare/setns | MEDIUM | Allowed for build tools, potential namespace escape |
| DNS wildcard pinning | MEDIUM | Wildcards bypass IP pinning |
| Symlink following in snapshots | MEDIUM | cp -a follows symlinks outside scope |
| Commit signing | MEDIUM | Agent commits are unsigned |
| RELEASE_TOKEN documentation | MEDIUM | Scope requirements undocumented |

### 6.2 Partially Addressed

| Feature | Current State | Remaining Gap |
|---------|--------------|---------------|
| yq integrity | SHA256 on amd64 | arm64 missing; failure non-fatal |
| Branch protection | Setup script available | Not enforced as prerequisite |
| SELinux/AppArmor | Detection + profile loading | Profiles not widely deployed |
| Seccomp profiles | Base profile implemented | Missing explicit deny rules for keyctl, ptrace, mount, bpf |

---

## 7. Remediation Roadmap

### Phase 1: Critical

1. **Add SHA256 verification for all build-time downloads**
   - SDKMAN install script: Download, verify hash, then execute
   - NVM install script: Download, verify hash, then execute
   - Rust: Download installer, verify, then execute
   - Go: Download tarball, verify checksum, then extract
   - yq: Make hash check fatal; add arm64 hash

### Phase 2: High

2. **Validate CUSTOM_PACKAGES build argument**
   - Add input sanitization in `build-image.sh`
   - Reject metacharacters in package names

3. **Fix secrets env file TOCTOU**
   - Set `umask 0077` before mktemp in `launch-agent.sh`

### Phase 3: Medium

4. **Harden seccomp profiles**
   - Add explicit `SCMP_ACT_KILL` rules for keyctl, ptrace, mount, bpf, perf_event_open
   - Restrict or block unshare/setns in strict/paranoid profiles

5. **Improve DNS filtering security**
   - Block wildcard domains in strict/paranoid security profiles
   - Document wildcard DNS pinning limitations

6. **Improve LSM degradation handling**
   - Log prominent warnings when LSM disabled
   - Consider requiring LSM for `strict` profile

7. **Replace remaining eval patterns**
   - Use associative arrays for timer names (Bash 4+)
   - Parse dbus-launch output without eval

8. **Fix symlink following in snapshots**
   - Use `cp -P` or validate symlink targets before snapshotting

9. **Document trust boundaries**
   - AGENT_SCRIPT, CUSTOM_PACKAGES as trusted build inputs
   - RELEASE_TOKEN required scopes
   - Branch protection setup requirements

### Phase 4: Low

10. **Ongoing improvements**
    - Fix piped loop subshell patterns
    - Add log directory permissions
    - Implement commit signing
    - Add stricter path component validation in status.sh

---

## Conclusion

The Kapsis codebase has made significant security improvements since the previous scan (2025-12-26). Critical issues including eval injection, credential race conditions, unpinned GitHub Actions, and unquoted pipeline variables have all been addressed. The security architecture demonstrates strong defense-in-depth with rootless containers, capability dropping, seccomp support, network filtering, credential isolation, and comprehensive input validation.

The primary remaining concern is **build-time supply chain integrity** — several tool installers (SDKMAN, NVM, Rust, Go) are downloaded without cryptographic verification. While these downloads use HTTPS and are pinned to specific versions, adding SHA256 checksums would close this gap and bring build-time security in line with the already-strong runtime security model.

---

*Report generated by automated security scan on 2026-02-21. Manual review recommended for all findings.*
