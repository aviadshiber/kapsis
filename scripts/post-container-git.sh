#!/usr/bin/env bash
#===============================================================================
# Kapsis - Post-Container Git Operations
#
# Runs on HOST after container exits to handle git commit and push.
# This runs in a trusted environment with full git access, after the
# agent has made its changes in the sandboxed worktree.
#
# Security Model:
# - Executes on HOST (not in container)
# - Full git access for commit/push operations
# - Validates changes before committing
# - Generates PR-ready commit messages
#===============================================================================

set -euo pipefail

#===============================================================================
# COLORS
#===============================================================================
CYAN='\033[0;36m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

log_info() { echo -e "${CYAN}[POST-GIT]${NC} $*"; }
log_success() { echo -e "${GREEN}[POST-GIT]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[POST-GIT]${NC} $*"; }
log_error() { echo -e "${RED}[POST-GIT]${NC} $*" >&2; }

#===============================================================================
# CHECK FOR CHANGES
#
# Returns 0 if there are uncommitted changes, 1 otherwise.
#===============================================================================
has_changes() {
    local worktree_path="$1"

    cd "$worktree_path"

    # Check for any changes (staged, unstaged, or untracked)
    if git diff --quiet && git diff --cached --quiet && [[ -z "$(git status --porcelain)" ]]; then
        return 1
    fi
    return 0
}

#===============================================================================
# COMMIT CHANGES
#
# Stages and commits all changes in the worktree.
#===============================================================================
commit_changes() {
    local worktree_path="$1"
    local commit_message="$2"
    local agent_id="${3:-unknown}"

    cd "$worktree_path"

    log_info "Staging changes..."
    git add -A

    # Show what's being committed
    echo ""
    echo "┌────────────────────────────────────────────────────────────────────┐"
    echo "│ CHANGES TO COMMIT                                                  │"
    echo "└────────────────────────────────────────────────────────────────────┘"
    git status --short
    echo ""

    # Generate full commit message with metadata
    local full_message
    full_message=$(cat << EOF
${commit_message}

Generated by Kapsis AI Agent Sandbox
Agent ID: ${agent_id}
Worktree: $(basename "$worktree_path")
EOF
)

    # Commit
    if git commit -m "$full_message"; then
        log_success "Changes committed"
        echo ""
        log_info "Commit details:"
        git log --oneline -1
        echo ""
        return 0
    else
        log_warn "Commit failed or nothing to commit"
        return 1
    fi
}

#===============================================================================
# PUSH CHANGES
#
# Pushes the current branch to remote.
#===============================================================================
push_changes() {
    local worktree_path="$1"
    local remote="${2:-origin}"

    cd "$worktree_path"

    local branch
    branch=$(git rev-parse --abbrev-ref HEAD)

    echo ""
    echo "┌────────────────────────────────────────────────────────────────────┐"
    echo "│ PUSHING TO REMOTE                                                  │"
    echo "└────────────────────────────────────────────────────────────────────┘"
    echo "  Remote: $remote"
    echo "  Branch: $branch"
    echo ""

    if git push --set-upstream "$remote" "$branch"; then
        log_success "Push successful"

        # Generate PR URL
        generate_pr_url "$worktree_path" "$branch"

        return 0
    else
        log_error "Push failed"
        return 1
    fi
}

#===============================================================================
# GENERATE PR URL
#
# Outputs a clickable URL to create a PR for the branch.
#===============================================================================
generate_pr_url() {
    local worktree_path="$1"
    local branch="$2"

    cd "$worktree_path"

    local remote_url
    remote_url=$(git remote get-url origin 2>/dev/null || echo "")

    if [[ -z "$remote_url" ]]; then
        return
    fi

    echo ""
    echo "┌────────────────────────────────────────────────────────────────────┐"
    echo "│ CREATE PULL REQUEST                                                │"
    echo "└────────────────────────────────────────────────────────────────────┘"

    if [[ "$remote_url" == *"bitbucket"* ]]; then
        # Bitbucket Cloud
        local repo_path
        repo_path=$(echo "$remote_url" | sed -E 's|.*[:/]([^/]+/[^/]+)(\.git)?$|\1|' | sed 's/\.git$//')
        echo "  https://bitbucket.org/${repo_path}/pull-requests/new?source=${branch}"

    elif [[ "$remote_url" == ssh://* ]] || [[ "$remote_url" == https://*git* ]]; then
        # Generic Bitbucket Server / self-hosted git
        local base_url
        base_url=$(echo "$remote_url" | sed -E 's|^(https?://[^/]+).*|\1|' | sed -E 's|^ssh://([^@]+@)?([^:/]+).*|https://\2|')
        local repo_path
        repo_path=$(echo "$remote_url" | sed -E 's|.*[:/]([^/]+/[^/]+)(\.git)?$|\1|' | sed 's/\.git$//')
        echo "  ${base_url}/${repo_path}/pull-requests/new?source=${branch}"

    elif [[ "$remote_url" == *"github"* ]]; then
        # GitHub
        local repo_path
        repo_path=$(echo "$remote_url" | sed -E 's|.*github\.com[:/](.*)\.git|\1|' | sed 's/\.git$//')
        echo "  https://github.com/${repo_path}/compare/${branch}?expand=1"

    elif [[ "$remote_url" == *"gitlab"* ]]; then
        # GitLab
        local repo_path
        repo_path=$(echo "$remote_url" | sed -E 's|.*gitlab\.com[:/](.*)\.git|\1|' | sed 's/\.git$//')
        echo "  https://gitlab.com/${repo_path}/-/merge_requests/new?merge_request[source_branch]=${branch}"

    else
        echo "  (Unable to generate PR URL for this remote)"
    fi

    echo ""
}

#===============================================================================
# SYNC INDEX
#
# Copies the updated index from worktree to sanitized git directory
# so container changes are properly tracked.
#===============================================================================
sync_index_from_container() {
    local worktree_path="$1"
    local sanitized_git="$2"

    if [[ -f "$sanitized_git/index" ]]; then
        # The container may have staged files - copy index back
        cd "$worktree_path"

        # Read the worktree's gitdir
        local gitdir_content
        gitdir_content=$(cat "$worktree_path/.git")
        local worktree_gitdir="${gitdir_content#gitdir: }"

        if [[ -f "$sanitized_git/index" ]]; then
            log_info "Syncing index from container..."
            cp "$sanitized_git/index" "$worktree_gitdir/index" 2>/dev/null || true
        fi
    fi
}

#===============================================================================
# MAIN POST-CONTAINER WORKFLOW
#
# Orchestrates the full post-container git workflow:
# 1. Check for changes
# 2. Commit if changes exist
# 3. Push if requested
#===============================================================================
post_container_git() {
    local worktree_path="$1"
    local branch="$2"
    local commit_message="${3:-feat: AI agent changes}"
    local remote="${4:-origin}"
    local no_push="${5:-false}"
    local agent_id="${6:-unknown}"
    local sanitized_git="${7:-}"

    echo ""
    echo "┌────────────────────────────────────────────────────────────────────┐"
    echo "│ POST-CONTAINER GIT OPERATIONS                                      │"
    echo "└────────────────────────────────────────────────────────────────────┘"
    echo "  Worktree: $worktree_path"
    echo "  Branch:   $branch"
    echo ""

    # Sync index if sanitized git provided
    if [[ -n "$sanitized_git" && -d "$sanitized_git" ]]; then
        sync_index_from_container "$worktree_path" "$sanitized_git"
    fi

    # Check for changes
    if ! has_changes "$worktree_path"; then
        log_info "No changes to commit"
        return 0
    fi

    # Commit changes
    if ! commit_changes "$worktree_path" "$commit_message" "$agent_id"; then
        log_warn "Commit failed"
        return 1
    fi

    # Push if not disabled
    if [[ "$no_push" != "true" ]]; then
        if ! push_changes "$worktree_path" "$remote"; then
            log_warn "Push failed. Changes are committed locally."
            log_info "To push manually: cd $worktree_path && git push -u $remote $branch"
            return 1
        fi
    else
        log_info "Skipping push (--no-push specified)"
        log_info "To push: cd $worktree_path && git push -u $remote $branch"
    fi

    echo ""
    log_success "Post-container git operations complete"
    echo ""
    echo "To continue working on this branch:"
    echo "  cd $worktree_path"
    echo ""
    echo "Or re-run agent with same branch to continue:"
    echo "  ./launch-agent.sh <id> <project> --branch $branch"
    echo ""

    return 0
}

#===============================================================================
# MAIN (for standalone usage)
#===============================================================================
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    if [[ $# -lt 2 ]]; then
        echo "Usage: $0 <worktree-path> <branch> [commit-message] [remote] [no-push] [agent-id]"
        echo ""
        echo "Arguments:"
        echo "  worktree-path   Path to the git worktree"
        echo "  branch          Branch name"
        echo "  commit-message  Commit message (default: 'feat: AI agent changes')"
        echo "  remote          Git remote (default: 'origin')"
        echo "  no-push         Set to 'true' to skip push (default: 'false')"
        echo "  agent-id        Agent identifier for commit metadata"
        echo ""
        echo "Example:"
        echo "  $0 ~/.kapsis/worktrees/myproject-1 feature/DEV-123 'fix: resolve auth bug'"
        exit 1
    fi

    post_container_git "$@"
fi
