#!/usr/bin/env bash
#===============================================================================
# Kapsis - Post-Container Git Operations
#
# Runs on HOST after container exits to handle git commit and push.
# This runs in a trusted environment with full git access, after the
# agent has made its changes in the sandboxed worktree.
#
# Security Model:
# - Executes on HOST (not in container)
# - Full git access for commit/push operations
# - Validates changes before committing
# - Generates PR-ready commit messages
#===============================================================================

set -euo pipefail

# Script directory
POST_GIT_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source logging library (only if not already loaded)
if [[ -z "${_KAPSIS_LOGGING_LOADED:-}" ]]; then
    source "$POST_GIT_SCRIPT_DIR/lib/logging.sh"
    log_init "post-container-git"
fi

# Source status reporting library (only if not already loaded)
if [[ -z "${_KAPSIS_STATUS_LOADED:-}" ]]; then
    source "$POST_GIT_SCRIPT_DIR/lib/status.sh"
fi

# Note: logging functions are provided by lib/logging.sh
# Note: status functions are provided by lib/status.sh

#===============================================================================
# CHECK FOR CHANGES
#
# Returns 0 if there are uncommitted changes, 1 otherwise.
#===============================================================================
has_changes() {
    local worktree_path="$1"

    cd "$worktree_path"

    # Check for any changes (staged, unstaged, or untracked)
    if git diff --quiet && git diff --cached --quiet && [[ -z "$(git status --porcelain)" ]]; then
        return 1
    fi
    return 0
}

#===============================================================================
# COMMIT CHANGES
#
# Stages and commits all changes in the worktree.
#===============================================================================
commit_changes() {
    local worktree_path="$1"
    local commit_message="$2"
    local agent_id="${3:-unknown}"

    cd "$worktree_path"

    log_info "Staging changes..."
    git add -A

    # Show what's being committed
    echo ""
    echo "┌────────────────────────────────────────────────────────────────────┐"
    echo "│ CHANGES TO COMMIT                                                  │"
    echo "└────────────────────────────────────────────────────────────────────┘"
    git status --short
    echo ""

    # Generate full commit message with metadata
    local full_message
    full_message=$(cat << EOF
${commit_message}

Generated by Kapsis AI Agent Sandbox
Agent ID: ${agent_id}
Worktree: $(basename "$worktree_path")
EOF
)

    # Commit
    if git commit -m "$full_message"; then
        log_success "Changes committed"
        echo ""
        log_info "Commit details:"
        git log --oneline -1
        echo ""
        return 0
    else
        log_warn "Commit failed or nothing to commit"
        return 1
    fi
}

#===============================================================================
# VERIFY PUSH
#
# Verifies that the push actually succeeded by comparing local and remote HEAD.
# This addresses the issue where push may report success but commits aren't
# actually on the remote (network issues, partial failures, etc.).
#
# Returns: 0 if verified, 1 if verification failed
#===============================================================================
verify_push() {
    local worktree_path="$1"
    local remote="${2:-origin}"
    local branch="${3:-}"

    cd "$worktree_path"

    # Get current branch if not specified
    if [[ -z "$branch" ]]; then
        branch=$(git rev-parse --abbrev-ref HEAD)
    fi

    log_info "Verifying push to ${remote}/${branch}..."

    # Get local HEAD commit
    local local_commit
    local_commit=$(git rev-parse HEAD 2>/dev/null)
    if [[ -z "$local_commit" ]]; then
        log_error "Could not determine local HEAD commit"
        status_set_push_info "failed" "" ""
        return 1
    fi
    log_debug "Local commit: $local_commit"

    # Fetch latest from remote to ensure we have current state
    if ! git fetch "$remote" "$branch" --quiet 2>/dev/null; then
        log_warn "Could not fetch from remote for verification"
        # Don't fail - the push might have worked even if fetch fails
        status_set_push_info "unverified" "$local_commit" ""
        return 0
    fi

    # Get remote HEAD commit after fetch
    local remote_commit
    remote_commit=$(git rev-parse "${remote}/${branch}" 2>/dev/null)
    log_debug "Remote commit: ${remote_commit:-unknown}"

    # Compare commits
    if [[ "$local_commit" == "$remote_commit" ]]; then
        log_success "Push verified: local and remote HEAD match"
        log_info "  Commit: ${local_commit:0:12}"
        status_set_push_info "success" "$local_commit" "$remote_commit"
        return 0
    else
        log_error "Push verification FAILED: commits do not match!"
        log_error "  Local:  $local_commit"
        log_error "  Remote: ${remote_commit:-not found}"
        status_set_push_info "failed" "$local_commit" "${remote_commit:-unknown}"
        return 1
    fi
}

#===============================================================================
# PUSH CHANGES
#
# Pushes the current branch to remote and verifies the push succeeded.
#===============================================================================
push_changes() {
    local worktree_path="$1"
    local remote="${2:-origin}"

    cd "$worktree_path"

    local branch
    branch=$(git rev-parse --abbrev-ref HEAD)

    echo ""
    echo "┌────────────────────────────────────────────────────────────────────┐"
    echo "│ PUSHING TO REMOTE                                                  │"
    echo "└────────────────────────────────────────────────────────────────────┘"
    echo "  Remote: $remote"
    echo "  Branch: $branch"
    echo ""

    # Capture local commit before push for verification
    local local_commit
    local_commit=$(git rev-parse HEAD 2>/dev/null)

    if git push --set-upstream "$remote" "$branch"; then
        log_success "Push command completed"

        # Verify the push actually succeeded
        echo ""
        if verify_push "$worktree_path" "$remote" "$branch"; then
            # Generate PR URL only after verified push
            generate_pr_url "$worktree_path" "$branch"
            return 0
        else
            log_error "Push reported success but verification failed!"
            log_error "Commits may not have been pushed to remote."
            return 2  # Distinct exit code for verification failure
        fi
    else
        log_error "Push failed"
        status_set_push_info "failed" "$local_commit" ""
        return 1
    fi
}

#===============================================================================
# GENERATE PR URL
#
# Outputs a clickable URL to create a PR for the branch.
# Also sets the global PR_URL variable for status reporting.
#===============================================================================
# Global variable for PR URL (set by generate_pr_url, used by status reporting)
export PR_URL=""

generate_pr_url() {
    local worktree_path="$1"
    local branch="$2"

    cd "$worktree_path"

    local remote_url
    remote_url=$(git remote get-url origin 2>/dev/null || echo "")

    if [[ -z "$remote_url" ]]; then
        return
    fi

    echo ""
    echo "┌────────────────────────────────────────────────────────────────────┐"
    echo "│ CREATE PULL REQUEST                                                │"
    echo "└────────────────────────────────────────────────────────────────────┘"

    local pr_url=""
    if [[ "$remote_url" == *"bitbucket"* ]]; then
        # Bitbucket Cloud
        local repo_path
        repo_path=$(echo "$remote_url" | sed -E 's|.*[:/]([^/]+/[^/]+)(\.git)?$|\1|' | sed 's/\.git$//')
        pr_url="https://bitbucket.org/${repo_path}/pull-requests/new?source=${branch}"

    elif [[ "$remote_url" == ssh://* ]] || [[ "$remote_url" == https://*git* ]]; then
        # Generic Bitbucket Server / self-hosted git
        local base_url
        base_url=$(echo "$remote_url" | sed -E 's|^(https?://[^/]+).*|\1|' | sed -E 's|^ssh://([^@]+@)?([^:/]+).*|https://\2|')
        local repo_path
        repo_path=$(echo "$remote_url" | sed -E 's|.*[:/]([^/]+/[^/]+)(\.git)?$|\1|' | sed 's/\.git$//')
        pr_url="${base_url}/${repo_path}/pull-requests/new?source=${branch}"

    elif [[ "$remote_url" == *"github"* ]]; then
        # GitHub
        local repo_path
        repo_path=$(echo "$remote_url" | sed -E 's|.*github\.com[:/](.*)\.git|\1|' | sed 's/\.git$//')
        pr_url="https://github.com/${repo_path}/compare/${branch}?expand=1"

    elif [[ "$remote_url" == *"gitlab"* ]]; then
        # GitLab
        local repo_path
        repo_path=$(echo "$remote_url" | sed -E 's|.*gitlab\.com[:/](.*)\.git|\1|' | sed 's/\.git$//')
        pr_url="https://gitlab.com/${repo_path}/-/merge_requests/new?merge_request[source_branch]=${branch}"
    fi

    if [[ -n "$pr_url" ]]; then
        echo "  $pr_url"
        # Set global variable for status reporting
        PR_URL="$pr_url"
    else
        echo "  (Unable to generate PR URL for this remote)"
    fi

    echo ""
}

#===============================================================================
# SYNC INDEX
#
# Copies the updated index from worktree to sanitized git directory
# so container changes are properly tracked.
#===============================================================================
sync_index_from_container() {
    local worktree_path="$1"
    local sanitized_git="$2"

    if [[ -f "$sanitized_git/index" ]]; then
        # The container may have staged files - copy index back
        cd "$worktree_path"

        # Read the worktree's gitdir
        local gitdir_content
        gitdir_content=$(cat "$worktree_path/.git")
        local worktree_gitdir="${gitdir_content#gitdir: }"

        if [[ -f "$sanitized_git/index" ]]; then
            log_info "Syncing index from container..."
            cp "$sanitized_git/index" "$worktree_gitdir/index" 2>/dev/null || true
        fi
    fi
}

#===============================================================================
# MAIN POST-CONTAINER WORKFLOW
#
# Orchestrates the full post-container git workflow:
# 1. Check for changes
# 2. Commit if changes exist
# 3. Push if requested
#===============================================================================
post_container_git() {
    local worktree_path="$1"
    local branch="$2"
    local commit_message="${3:-feat: AI agent changes}"
    local remote="${4:-origin}"
    local no_push="${5:-false}"
    local agent_id="${6:-unknown}"
    local sanitized_git="${7:-}"

    log_debug "post_container_git called with:"
    log_debug "  worktree_path=$worktree_path"
    log_debug "  branch=$branch"
    log_debug "  commit_message=$commit_message"
    log_debug "  remote=$remote"
    log_debug "  no_push=$no_push"
    log_debug "  agent_id=$agent_id"
    log_debug "  sanitized_git=$sanitized_git"

    echo ""
    echo "┌────────────────────────────────────────────────────────────────────┐"
    echo "│ POST-CONTAINER GIT OPERATIONS                                      │"
    echo "└────────────────────────────────────────────────────────────────────┘"
    echo "  Worktree: $worktree_path"
    echo "  Branch:   $branch"
    echo ""

    # Sync index if sanitized git provided
    if [[ -n "$sanitized_git" && -d "$sanitized_git" ]]; then
        log_debug "Syncing index from sanitized git..."
        sync_index_from_container "$worktree_path" "$sanitized_git"
    fi

    # Check for changes
    log_debug "Checking for uncommitted changes..."
    if ! has_changes "$worktree_path"; then
        log_info "No changes to commit"
        return 0
    fi
    log_debug "Changes detected, proceeding with commit"

    # Update status: committing phase
    status_phase "committing" 92 "Staging and committing changes"

    # Commit changes
    log_debug "Committing changes..."
    if ! commit_changes "$worktree_path" "$commit_message" "$agent_id"; then
        log_warn "Commit failed"
        return 1
    fi
    log_debug "Commit successful"

    # Push if not disabled
    if [[ "$no_push" != "true" ]]; then
        # Update status: pushing phase
        status_phase "pushing" 97 "Pushing to remote"

        log_debug "Pushing changes to remote..."
        local push_result
        push_changes "$worktree_path" "$remote"
        push_result=$?

        if [[ $push_result -eq 0 ]]; then
            log_debug "Push successful and verified"
        elif [[ $push_result -eq 2 ]]; then
            # Push command succeeded but verification failed
            log_error "Push verification failed! Commits may not be on remote."
            log_info "To check: cd $worktree_path && git fetch && git log --oneline HEAD ^origin/$branch"
            return 2
        else
            log_warn "Push failed. Changes are committed locally."
            log_info "To push manually: cd $worktree_path && git push -u $remote $branch"
            return 1
        fi
    else
        log_info "Skipping push (--no-push specified)"
        log_info "To push: cd $worktree_path && git push -u $remote $branch"
        # Record that push was skipped with the local commit
        local local_commit
        local_commit=$(git -C "$worktree_path" rev-parse HEAD 2>/dev/null || echo "")
        status_push_skipped "$local_commit"
    fi

    echo ""
    log_success "Post-container git operations complete"
    echo ""
    echo "To continue working on this branch:"
    echo "  cd $worktree_path"
    echo ""
    echo "Or re-run agent with same branch to continue:"
    echo "  ./launch-agent.sh <id> <project> --branch $branch"
    echo ""

    return 0
}

#===============================================================================
# MAIN (for standalone usage)
#===============================================================================
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    if [[ $# -lt 2 ]]; then
        echo "Usage: $0 <worktree-path> <branch> [commit-message] [remote] [no-push] [agent-id]"
        echo ""
        echo "Arguments:"
        echo "  worktree-path   Path to the git worktree"
        echo "  branch          Branch name"
        echo "  commit-message  Commit message (default: 'feat: AI agent changes')"
        echo "  remote          Git remote (default: 'origin')"
        echo "  no-push         Set to 'true' to skip push (default: 'false')"
        echo "  agent-id        Agent identifier for commit metadata"
        echo ""
        echo "Example:"
        echo "  $0 ~/.kapsis/worktrees/myproject-1 feature/DEV-123 'fix: resolve auth bug'"
        exit 1
    fi

    post_container_git "$@"
fi
