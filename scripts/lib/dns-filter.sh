#!/usr/bin/env bash
#===============================================================================
# Kapsis DNS Filter Library
#
# Provides DNS-based network filtering using dnsmasq inside containers.
# Used by entrypoint.sh to set up filtered network mode.
#
# Features:
#   - Generates dnsmasq configuration from YAML allowlist
#   - Starts dnsmasq as a background process
#   - Validates allowlist domains
#   - Provides logging for blocked queries
#
# Usage:
#   source "$KAPSIS_HOME/lib/dns-filter.sh"
#   dns_filter_init "/etc/kapsis/network-allowlist.yaml"
#   dns_filter_start
#
# Environment Variables:
#   KAPSIS_NETWORK_MODE      - Network mode: none, filtered, open
#   KAPSIS_DNS_SERVERS       - Upstream DNS servers (default: 8.8.8.8,8.8.4.4)
#   KAPSIS_DNS_LOG_QUERIES   - Enable DNS query logging (default: false)
#   KAPSIS_DNS_CONFIG_FILE   - Path to generated dnsmasq config
#===============================================================================

# Prevent double-sourcing
[[ -n "${_KAPSIS_DNS_FILTER_LOADED:-}" ]] && return 0
_KAPSIS_DNS_FILTER_LOADED=1

# Configuration defaults
: "${KAPSIS_DNS_SERVERS:=8.8.8.8,8.8.4.4}"
: "${KAPSIS_DNS_LOG_QUERIES:=false}"
: "${KAPSIS_DNS_CONFIG_FILE:=/tmp/kapsis-dnsmasq.conf}"
: "${KAPSIS_DNS_LOG_FILE:=/tmp/kapsis-dns.log}"
: "${KAPSIS_DNS_PID_FILE:=/tmp/kapsis-dnsmasq.pid}"
: "${KAPSIS_DNS_PINNED_FILE:=/etc/kapsis/pinned-dns.conf}"

# Internal state
_DNS_FILTER_ALLOWLIST=""
_DNS_FILTER_STARTED=false

# Associative array to track pinned domains (avoid duplicate rules)
# Use declare -gA for global associative array (bash 4.2+)
# The -g flag makes it global even when sourced from a function
# Note: runs inside container only (bash 5+), associative arrays require bash 4.0+
declare -gA _KAPSIS_PINNED_DOMAINS 2>/dev/null || declare -A _KAPSIS_PINNED_DOMAINS 2>/dev/null || true

#===============================================================================
# LOGGING HELPERS
#===============================================================================

# Define logging fallbacks for any missing functions
# Each function is checked independently since partial definitions may exist
type log_info &>/dev/null || log_info() { echo "[DNS-FILTER] INFO: $*" >&2; }
type log_debug &>/dev/null || log_debug() { [[ -n "${KAPSIS_DEBUG:-}" ]] && echo "[DNS-FILTER] DEBUG: $*" >&2 || true; }
type log_warn &>/dev/null || log_warn() { echo "[DNS-FILTER] WARN: $*" >&2; }
type log_error &>/dev/null || log_error() { echo "[DNS-FILTER] ERROR: $*" >&2; }
type log_success &>/dev/null || log_success() { echo "[DNS-FILTER] SUCCESS: $*" >&2; }

#===============================================================================
# DOMAIN VALIDATION
#===============================================================================

# Validate a domain pattern
# Supports: domain.com, *.domain.com, sub.domain.com
# Returns: 0 if valid, 1 if invalid
validate_domain_pattern() {
    local domain="$1"

    # Remove leading/trailing whitespace
    domain=$(echo "$domain" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')

    # Empty domain is invalid
    [[ -z "$domain" ]] && return 1

    # Skip comments
    [[ "$domain" == "#"* ]] && return 1

    # Remove wildcard prefix for validation
    local check_domain="${domain#\*.}"

    # Basic domain validation
    # - Must contain at least one dot (except for wildcards)
    # - Only alphanumeric, hyphens, and dots allowed
    # - No consecutive dots
    # - No leading/trailing hyphens in labels
    if [[ "$domain" == "*" ]]; then
        return 1  # Bare wildcard not allowed
    fi

    if [[ ! "$check_domain" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?)*$ ]]; then
        log_debug "Invalid domain format: $domain"
        return 1
    fi

    return 0
}

#===============================================================================
# DNSMASQ CONFIGURATION GENERATION
#===============================================================================

# Convert YAML allowlist to dnsmasq configuration
# Arguments:
#   $1 - Path to allowlist YAML file (optional, uses env vars if not provided)
# Output:
#   Writes dnsmasq config to KAPSIS_DNS_CONFIG_FILE
generate_dnsmasq_config() {
    local allowlist_file="${1:-}"
    local config_file="${KAPSIS_DNS_CONFIG_FILE}"
    local pinned_file="${KAPSIS_DNS_PINNED_FILE}"

    log_info "Generating dnsmasq configuration..."

    # Get upstream DNS servers
    local dns_servers="${KAPSIS_DNS_SERVERS}"
    local primary_dns="${dns_servers%%,*}"

    # Reset pinned domains tracking
    _KAPSIS_PINNED_DOMAINS=()

    # Start configuration
    cat > "$config_file" << 'EOF'
#===============================================================================
# Kapsis DNS Filter Configuration
# Generated by dns-filter.sh - DO NOT EDIT
#===============================================================================

# Basic settings
domain-needed
bogus-priv
no-resolv
no-poll
no-hosts

# Security: prevent DNS rebinding attacks
# Rejects responses containing private IP ranges (RFC1918)
stop-dns-rebind
rebind-localhost-ok

# Listen only on localhost
listen-address=127.0.0.1
bind-interfaces
port=53

# Cache settings
cache-size=1000

EOF

    # Add logging if enabled
    if [[ "$KAPSIS_DNS_LOG_QUERIES" == "true" ]]; then
        cat >> "$config_file" << EOF
# DNS query logging enabled
log-queries
log-facility=${KAPSIS_DNS_LOG_FILE}

EOF
    fi

    #===========================================================================
    # PINNED DNS ENTRIES (host-resolved IPs)
    #
    # If pinned DNS file exists (from host-side resolution), use static
    # address=/ directives instead of dynamic server=/ forwarding.
    # This prevents DNS manipulation attacks inside the container.
    #===========================================================================
    local pinned_count=0

    if [[ -f "$pinned_file" ]]; then
        log_info "Loading pinned DNS entries from host resolution..."
        echo "" >> "$config_file"
        echo "# Pinned domains (resolved on host - IP addresses fixed)" >> "$config_file"
        echo "" >> "$config_file"

        while IFS= read -r line; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" == "#"* ]] && continue

            # Parse: domain IP1 IP2 ...
            local pin_domain
            pin_domain=$(echo "$line" | awk '{print $1}')
            local pin_ips
            pin_ips=$(echo "$line" | cut -d' ' -f2-)

            [[ -z "$pin_domain" || -z "$pin_ips" ]] && continue

            # Track this domain as pinned (skip in dynamic rules later)
            _KAPSIS_PINNED_DOMAINS["$pin_domain"]=1

            # Generate address= directive for each IP
            # shellcheck disable=SC2086  # Intentional word-split: $pin_ips contains space-separated IPs
            for ip in $pin_ips; do
                echo "address=/${pin_domain}/${ip}" >> "$config_file"
            done

            log_debug "Pinned: $pin_domain -> $pin_ips"
            ((pinned_count++))
        done < "$pinned_file"

        log_success "Loaded $pinned_count pinned domain(s) from host resolution"
    else
        log_debug "No pinned DNS file found at $pinned_file"
    fi

    # Block everything by default
    cat >> "$config_file" << 'EOF'
# Block all domains by default (return NXDOMAIN)
address=/#/0.0.0.0
address=/::/::

EOF

    # Process allowlist from YAML file
    local domain_count=0

    if [[ -n "$allowlist_file" && -f "$allowlist_file" ]]; then
        log_debug "Processing allowlist file: $allowlist_file"

        # Check if yq is available
        if ! command -v yq &>/dev/null; then
            log_warn "yq not found, using environment-based allowlist only"
        else
            # Extract all domains from the allowlist (hosts, registries, custom, containers, ai)
            # Uses yq v4 (mikefarah/yq) syntax
            local domains
            domains=$(yq eval '
                ((.network.allowlist.hosts // [])[] // ""),
                ((.network.allowlist.registries // [])[] // ""),
                ((.network.allowlist.containers // [])[] // ""),
                ((.network.allowlist.ai // [])[] // ""),
                ((.network.allowlist.custom // [])[] // "")
            ' "$allowlist_file" 2>/dev/null | sort -u)

            # Extract DNS servers from allowlist if present
            local allowlist_dns
            allowlist_dns=$(yq eval '(.network.dns_servers // [])[]' "$allowlist_file" 2>/dev/null | head -1)
            if [[ -n "$allowlist_dns" ]]; then
                primary_dns="$allowlist_dns"
                log_debug "Using DNS server from allowlist: $primary_dns"
            fi

            echo "# Allowed domains (from $allowlist_file)" >> "$config_file"
            echo "" >> "$config_file"

            while IFS= read -r domain; do
                [[ -z "$domain" ]] && continue
                [[ "$domain" == "null" ]] && continue

                # Remove quotes if present
                domain="${domain#\"}"
                domain="${domain%\"}"

                # Skip if already pinned with static IP
                if [[ -n "${_KAPSIS_PINNED_DOMAINS[$domain]:-}" ]]; then
                    log_debug "Skipping $domain - already pinned with static IP"
                    continue
                fi

                if validate_domain_pattern "$domain"; then
                    # Handle wildcard domains (cannot be IP-pinned)
                    if [[ "$domain" == "*."* ]]; then
                        local base_domain="${domain#\*.}"
                        echo "server=/.${base_domain}/${primary_dns}" >> "$config_file"
                        log_debug "Added wildcard domain: *.${base_domain}"
                        # Security warning: wildcards are vulnerable to DNS manipulation
                        if [[ "${KAPSIS_DNS_PIN_ENABLED:-false}" == "true" ]]; then
                            log_warn "SECURITY: Wildcard '$domain' cannot be IP-pinned - vulnerable to DNS manipulation"
                            log_warn "  Consider using concrete subdomains for better security"
                        fi
                    else
                        echo "server=/${domain}/${primary_dns}" >> "$config_file"
                        log_debug "Added domain: $domain"
                    fi
                    ((domain_count++))
                else
                    log_warn "Skipping invalid domain: $domain"
                fi
            done <<< "$domains"
        fi
    fi

    # Process environment-based allowlist (KAPSIS_DNS_ALLOWLIST)
    if [[ -n "${KAPSIS_DNS_ALLOWLIST:-}" ]]; then
        echo "" >> "$config_file"
        echo "# Allowed domains (from KAPSIS_DNS_ALLOWLIST env)" >> "$config_file"
        echo "" >> "$config_file"

        IFS=',' read -ra env_domains <<< "$KAPSIS_DNS_ALLOWLIST"
        for domain in "${env_domains[@]}"; do
            domain=$(echo "$domain" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
            [[ -z "$domain" ]] && continue

            # Skip if already pinned with static IP
            if [[ -n "${_KAPSIS_PINNED_DOMAINS[$domain]:-}" ]]; then
                log_debug "Skipping $domain - already pinned with static IP"
                continue
            fi

            if validate_domain_pattern "$domain"; then
                if [[ "$domain" == "*."* ]]; then
                    local base_domain="${domain#\*.}"
                    echo "server=/.${base_domain}/${primary_dns}" >> "$config_file"
                    # Security warning for wildcards
                    if [[ "${KAPSIS_DNS_PIN_ENABLED:-false}" == "true" ]]; then
                        log_warn "SECURITY: Wildcard '$domain' cannot be IP-pinned - vulnerable to DNS manipulation"
                    fi
                else
                    echo "server=/${domain}/${primary_dns}" >> "$config_file"
                fi
                ((domain_count++))
            fi
        done
    fi

    # Set permissions (600 = owner read/write only, contains DNS config)
    chmod 600 "$config_file"

    log_success "dnsmasq config generated: $domain_count domains allowed"
    log_debug "Config file: $config_file"

    return 0
}

#===============================================================================
# DNSMASQ STARTUP
#===============================================================================

# Start dnsmasq with the generated configuration
# Returns: 0 on success, 1 on failure
start_dns_filter() {
    local config_file="${KAPSIS_DNS_CONFIG_FILE}"
    local pid_file="${KAPSIS_DNS_PID_FILE}"

    log_info "Starting DNS filter (dnsmasq)..."

    # Check if dnsmasq is available
    if ! command -v dnsmasq &>/dev/null; then
        log_error "dnsmasq not installed"
        return 1
    fi

    # Check if config file exists
    if [[ ! -f "$config_file" ]]; then
        log_error "dnsmasq config not found: $config_file"
        log_error "Run generate_dnsmasq_config first"
        return 1
    fi

    # Stop existing dnsmasq if running
    stop_dns_filter

    # Create log file if logging enabled (600 = owner only, may contain sensitive queries)
    if [[ "$KAPSIS_DNS_LOG_QUERIES" == "true" ]]; then
        touch "$KAPSIS_DNS_LOG_FILE" 2>/dev/null || true
        chmod 600 "$KAPSIS_DNS_LOG_FILE" 2>/dev/null || true
    fi

    # Start dnsmasq
    # Note: We run as foreground with --keep-in-foreground for better control
    # but background it ourselves with &
    if ! dnsmasq --conf-file="$config_file" --pid-file="$pid_file" 2>/dev/null; then
        log_error "Failed to start dnsmasq"
        return 1
    fi

    # Wait briefly for startup
    sleep 0.5

    # Verify it's running
    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file" 2>/dev/null)
        if kill -0 "$pid" 2>/dev/null; then
            log_success "dnsmasq started (PID: $pid)"
            _DNS_FILTER_STARTED=true
            return 0
        fi
    fi

    log_error "dnsmasq failed to start properly"
    return 1
}

# Stop dnsmasq if running
stop_dns_filter() {
    local pid_file="${KAPSIS_DNS_PID_FILE}"

    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            log_debug "Stopping dnsmasq (PID: $pid)"
            kill "$pid" 2>/dev/null || true
            rm -f "$pid_file"
        fi
    fi

    # Also try to kill any running dnsmasq (belt and suspenders)
    pkill -f "dnsmasq.*kapsis" 2>/dev/null || true

    _DNS_FILTER_STARTED=false
}

# Check if DNS filter is running
is_dns_filter_running() {
    local pid_file="${KAPSIS_DNS_PID_FILE}"

    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
    fi
    return 1
}

#===============================================================================
# RESOLV.CONF SETUP
#===============================================================================

# Configure container's resolv.conf to use local dnsmasq
# Returns: 0 on success, 1 on failure
setup_resolv_conf() {
    local resolv_conf="/etc/resolv.conf"

    log_info "Configuring DNS resolution to use local filter..."

    # Backup original resolv.conf
    if [[ -f "$resolv_conf" ]]; then
        cp "$resolv_conf" "${resolv_conf}.kapsis-backup" 2>/dev/null || true
    fi

    # Point to local dnsmasq
    cat > "$resolv_conf" << 'EOF'
# Kapsis DNS Filter - managed by dns-filter.sh
# All DNS queries go through local dnsmasq for filtering
nameserver 127.0.0.1
EOF

    log_success "DNS resolution configured to use local filter"
    return 0
}

# Restore original resolv.conf
restore_resolv_conf() {
    local resolv_conf="/etc/resolv.conf"
    local backup="${resolv_conf}.kapsis-backup"

    if [[ -f "$backup" ]]; then
        mv "$backup" "$resolv_conf" 2>/dev/null || true
        log_info "DNS resolution restored to original"
    fi
}

#===============================================================================
# MAIN ENTRY POINT
#===============================================================================

# Initialize and start DNS filtering
# Arguments:
#   $1 - Path to allowlist YAML file (optional)
# Returns: 0 on success, 1 on failure
dns_filter_init() {
    local allowlist_file="${1:-}"

    log_info "Initializing DNS filter..."

    # Generate configuration
    if ! generate_dnsmasq_config "$allowlist_file"; then
        log_error "Failed to generate dnsmasq configuration"
        return 1
    fi

    # Start dnsmasq
    if ! start_dns_filter; then
        log_error "Failed to start dnsmasq"
        return 1
    fi

    # Configure resolv.conf
    if ! setup_resolv_conf; then
        log_warn "Failed to configure resolv.conf - DNS filtering may not work"
        # Don't fail completely - dnsmasq is running
    fi

    # Verify filtering is actually working
    # shellcheck disable=SC2119  # Optional arg not needed for basic verification
    if ! verify_dns_filtering; then
        log_error "DNS filtering verification failed"
        return 1
    fi

    log_success "DNS filtering initialized and active"
    return 0
}

# Cleanup function (call on container exit)
dns_filter_cleanup() {
    log_info "Cleaning up DNS filter..."
    stop_dns_filter
    restore_resolv_conf
}

# Test DNS resolution
# Arguments:
#   $1 - Domain to test
# Returns: 0 if resolves, 1 if blocked
dns_filter_test() {
    local domain="$1"

    if [[ -z "$domain" ]]; then
        log_error "Usage: dns_filter_test <domain>"
        return 1
    fi

    log_info "Testing DNS resolution for: $domain"

    local result
    if result=$(nslookup "$domain" 127.0.0.1 2>&1); then
        if echo "$result" | grep -q "0.0.0.0\|NXDOMAIN\|can't find"; then
            log_info "  Result: BLOCKED (returned NXDOMAIN/0.0.0.0)"
            return 1
        else
            log_info "  Result: ALLOWED (resolved successfully)"
            return 0
        fi
    else
        log_info "  Result: BLOCKED (lookup failed)"
        return 1
    fi
}

# Verify DNS filtering is working correctly
# Tests that blocked domains fail and optionally that allowed domains resolve
# Arguments:
#   $1 - Optional domain to verify is allowed (for future use/testing)
# Returns: 0 if verification passes, 1 if filtering is not working
# shellcheck disable=SC2120  # Optional arg for future use
verify_dns_filtering() {
    local test_allowed="${1:-}"
    local test_blocked="kapsis-verify-blocked.invalid"

    log_info "Verifying DNS filtering is active..."

    # Test that blocked domain returns NXDOMAIN/0.0.0.0
    local blocked_result
    blocked_result=$(nslookup "$test_blocked" 127.0.0.1 2>&1) || true

    if echo "$blocked_result" | grep -qE "(NXDOMAIN|0\.0\.0\.0|SERVFAIL|can't find)"; then
        log_debug "Blocked domain test passed (returned NXDOMAIN)"
    else
        log_error "DNS filtering verification FAILED"
        log_error "Blocked domain '$test_blocked' should not resolve but got:"
        log_error "$blocked_result"
        return 1
    fi

    # If an allowed domain was provided, verify it resolves
    if [[ -n "$test_allowed" ]]; then
        local allowed_result
        allowed_result=$(nslookup "$test_allowed" 127.0.0.1 2>&1) || true

        if echo "$allowed_result" | grep -qE "Address:.*[0-9]+\.[0-9]+"; then
            log_debug "Allowed domain test passed ($test_allowed resolved)"
        else
            log_warn "Allowed domain '$test_allowed' did not resolve"
            log_warn "This may indicate network issues, not a filtering failure"
            # Don't fail - could be transient network issue
        fi
    fi

    log_success "DNS filtering verified"
    return 0
}

#===============================================================================
# DNS FILE PROTECTION
#===============================================================================

# Protect DNS configuration files from modification inside the container.
# Sets /etc/resolv.conf and /etc/hosts to read-only (chmod 444).
# Agent runs as non-root and cannot override these permissions.
#
# This prevents attack vectors where the agent:
#   1. Kills dnsmasq process
#   2. Modifies /etc/resolv.conf to bypass filtering
#   3. Adds entries to /etc/hosts to redirect domains
#
# Environment:
#   KAPSIS_DNS_PIN_PROTECT_FILES - Set to "true" to enable protection
#
# Returns: 0 on success, 1 on failure (continues with warning)
protect_dns_files() {
    if [[ "${KAPSIS_DNS_PIN_PROTECT_FILES:-false}" != "true" ]]; then
        log_debug "DNS file protection not enabled"
        return 0
    fi

    log_info "Protecting DNS configuration files..."

    local protected=0
    local failed=0

    # Protect /etc/resolv.conf
    if [[ -f /etc/resolv.conf ]]; then
        if chmod 444 /etc/resolv.conf 2>/dev/null; then
            log_debug "Protected /etc/resolv.conf (read-only)"
            ((protected++))
        else
            log_warn "Cannot protect /etc/resolv.conf - may require root"
            ((failed++))
        fi
    fi

    # Protect /etc/hosts
    if [[ -f /etc/hosts ]]; then
        if chmod 444 /etc/hosts 2>/dev/null; then
            log_debug "Protected /etc/hosts (read-only)"
            ((protected++))
        else
            log_warn "Cannot protect /etc/hosts - may require root"
            ((failed++))
        fi
    fi

    if [[ "$protected" -gt 0 ]]; then
        log_success "DNS files protected ($protected file(s) set to read-only)"
    fi

    # Return success even if some files couldn't be protected
    # (the chmod failure is not fatal, just reduces security)
    return 0
}
